<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Jmsimplifyutils by jimmyleeking</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Jmsimplifyutils</h1>
      <h2 class="project-tagline">关于实现获取曲线的关键特征点获取的工具类，包含对Ramer–Douglas–Peucker算法的实现。</h2>
      <a href="https://github.com/jimmyleeking/JMSimplifyUtils" class="btn">View on GitHub</a>
      <a href="https://github.com/jimmyleeking/JMSimplifyUtils/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/jimmyleeking/JMSimplifyUtils/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="jmsimplifyutils" class="anchor" href="#jmsimplifyutils" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>JMSimplifyUtils</h1>

<h2>
<a id="description" class="anchor" href="#description" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Description</h2>

<p>假设我们绘制一条曲线，但是这条曲线可能就是一条折线，那么构成这条折线的组成关键点就只需要3个点，这三个点就是“关键特征点”。</p>

<p><img src="https://raw.githubusercontent.com/jimmyleeking/KeyPointView/master/demo.png" alt="image"></p>

<p>最早考虑使用Ramer–Douglas–Peucker，后面简称RDP,这个通常意义上的路径压缩算法来实现，但是后来发现如果这个算法不改进的话，会存在一个严重的问题：起始点和终点小于容忍度的话，那么只能得到起点和终点，所有中间点都会被忽略，而且你无法按照你想获取的最大点数来获取关键特征点。</p>

<p>于是，自己又通过简单的三角函数+归并算法，来实现对路径的特征关键点进行提取。</p>

<p>具体算法描述如下：</p>

<ol>
<li>将曲线点左右两组。</li>
<li>计算组是否为最小组，不是，则继续划分，是则计算最小组，得到最新的关键特征点。</li>
<li>将计算过后的过滤点左右两组合并，得到所需的组关键特征点。</li>
</ol>

<p>最小组关键特征点的算法描述：</p>

<p>假设有a,b,c,d三个点：</p>

<ol>
<li>取a,b,c三个点计算夹角A,取b,c,d三个点计算夹角B</li>
<li>如果夹角A比夹角B小的话，就过滤掉b点，反之过滤c。</li>
<li>返回最终的三个点。</li>
</ol>

<p>得到具体效果如下：</p>

<p><img src="https://raw.githubusercontent.com/jimmyleeking/KeyPointView/master/demoShow.gif" alt="image"></p>

<p>在使用效果来看，自己的角度算法得到的效果要优于RDP算法，感兴趣的话，可以手动在Demo中切换获取关键点的方式，这里JMSimplifyUtils提供了两种方式来让你得到关键特征点。</p>

<p>使用方法如下：</p>

<h2>
<a id="user-guide" class="anchor" href="#user-guide" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>User Guide</h2>

<p>通过RDP算法，来获取关键特征点,pointArray:需要计算的曲线点组,tolerance:最小容忍度
(最小容忍度一般可以设置为手机的dpi值)</p>

<p><code>
+(NSMutableArray *)simplifyByRDP:(NSArray *)pointArray tolerance:(double)tolerance;
</code></p>

<p>通过三角函数+归并算法计算关键特征点</p>

<p>pointArray：需要计算的曲线点组
maxCount:需要获取最大关键特征点的个数</p>

<p><code>
+(NSMutableArray *)simplifyByAngle:(NSArray *)pointArray maxCount:(NSInteger)maxCount;
</code></p>

<h2>
<a id="mit-licence" class="anchor" href="#mit-licence" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>MIT Licence</h2>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/jimmyleeking/JMSimplifyUtils">Jmsimplifyutils</a> is maintained by <a href="https://github.com/jimmyleeking">jimmyleeking</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
